name: Live Bot - Short Run Test

on:
  workflow_dispatch:
    inputs:
      duration_seconds:
        description: 'Duration to run the bot (seconds)'
        required: false
        default: '180'
        type: number
      execution_mode:
        description: 'Execution mode'
        required: false
        default: 'ts-node'
        type: choice
        options:
        - 'ts-node'
        - 'compiled'
      log_level:
        description: 'Log level'
        required: false
        default: 'info'
        type: choice
        options:
        - 'debug'
        - 'info'
        - 'warn'
      bot_command:
        description: 'Bot command to execute'
        required: false
        default: 'start'
        type: choice
        options:
        - 'start'
        - 'status'
      fork_preflight:
        description: 'Enable fork simulation preflight (high memory usage)'
        required: false
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'

concurrency:
  group: live-bot-run
  cancel-in-progress: true

jobs:
  live-bot-test:
    name: Run Live Bot for Limited Time
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      actions: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Preflight checks - Required secrets
      run: |
        echo "üîç Checking required secrets..."
        
        # Check critical secrets
        if [ -z "${{ secrets.RPC_URL_HTTP }}" ]; then
          echo "‚ùå CRITICAL: RPC_URL_HTTP secret is not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.PRIVATE_KEY }}" ]; then
          echo "‚ùå CRITICAL: PRIVATE_KEY secret is not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.ETHERSCAN_API_KEY }}" ]; then
          echo "‚ùå CRITICAL: ETHERSCAN_API_KEY secret is not set"
          exit 1
        fi
        
        echo "‚úÖ All required secrets are present"
        
    - name: Preflight checks - Safety toggles
      run: |
        echo "üîí Checking safety toggles..."
        
        # Check safety acknowledgment
        if [ "${{ vars.I_UNDERSTAND_LIVE_RISK }}" != "true" ]; then
          echo "‚ùå SAFETY: I_UNDERSTAND_LIVE_RISK must be set to 'true' in repository variables"
          echo "   This confirms you understand the risks of running the bot with real funds"
          exit 1
        fi
        
        # Check mainnet confirmation
        if [ "${{ vars.CONFIRM_MAINNET }}" != "true" ]; then
          echo "‚ùå SAFETY: CONFIRM_MAINNET must be set to 'true' in repository variables"
          echo "   This confirms you want to run on mainnet"
          exit 1
        fi
        
        echo "‚úÖ Safety toggles confirmed"
        
    - name: Environment summary
      run: |
        echo "üîß Environment Configuration Summary:"
        echo "   Duration: ${{ inputs.duration_seconds }} seconds"
        echo "   Mode: ${{ inputs.execution_mode }}"
        echo "   Log Level: ${{ inputs.log_level }}"
        echo "   Bot Command: ${{ inputs.bot_command }}"
        echo "   Fork Preflight: ${{ inputs.fork_preflight }}"
        echo "   Node.js Heap: 6GB (enhanced for memory-intensive operations)"
        echo ""
        echo "üîê Configured Secrets (masked):"
        echo "   RPC_URL_HTTP: $(echo '${{ secrets.RPC_URL_HTTP }}' | sed 's/.*/***/g')"
        echo "   RPC_URL_WS: $(echo '${{ secrets.RPC_URL_WS }}' | sed 's/.*/***/g' || echo 'Not set')"
        echo "   PRIVATE_KEY: ***"
        echo "   FLASHBOTS_SIGNING_KEY: $([ -n '${{ secrets.FLASHBOTS_SIGNING_KEY }}' ] && echo '***' || echo 'Not set')"
        echo "   FLASHBOTS_RELAY_URL: $(echo '${{ secrets.FLASHBOTS_RELAY_URL }}' | sed 's/.*/***/g' || echo 'Not set')"
        echo "   ETHERSCAN_API_KEY: ***"
        echo "   BLOCKNATIVE_API_KEY: $([ -n '${{ secrets.BLOCKNATIVE_API_KEY }}' ] && echo '***' || echo 'Not set')"
        echo ""
        echo "‚öôÔ∏è  Configured Variables:"
        echo "   SIMULATION_MODE: ${{ vars.SIMULATION_MODE }}"
        echo "   ENABLE_FLASHBOTS: ${{ vars.ENABLE_FLASHBOTS }}"
        echo "   ENABLE_FORK_SIM_PREFLIGHT: ${{ inputs.fork_preflight }}"
        echo "   MAX_FLASHLOAN_AMOUNT_USD: ${{ vars.MAX_FLASHLOAN_AMOUNT_USD }}"
        echo "   GLOBAL_MIN_PROFIT_USD: ${{ vars.GLOBAL_MIN_PROFIT_USD }}"
        echo "   MAX_GAS_GWEI: ${{ vars.MAX_GAS_GWEI }}"
        echo "   BUNDLE_GAS_LIMIT: ${{ vars.BUNDLE_GAS_LIMIT }}"
        echo "   POOL_MAX_FAILURES: ${{ vars.POOL_MAX_FAILURES }}"
        echo "   POOL_COOLDOWN_MS: ${{ vars.POOL_COOLDOWN_MS }}"
        echo "   REQUIRE_RAW_TX_HEX: ${{ vars.REQUIRE_RAW_TX_HEX }}"
        echo "   ONE_BUNDLE_PER_BLOCK: ${{ vars.ONE_BUNDLE_PER_BLOCK }}"
        echo "   I_UNDERSTAND_LIVE_RISK: ${{ vars.I_UNDERSTAND_LIVE_RISK }}"
        echo "   CONFIRM_MAINNET: ${{ vars.CONFIRM_MAINNET }}"
        
    - name: Compile TypeScript (if needed)
      if: inputs.execution_mode == 'compiled'
      run: |
        echo "üî® Compiling TypeScript for execution_mode: compiled..."
        
        # First try npm run build, but check if it actually produces TypeScript output
        echo "Attempting npm run build..."
        npm run build
        
        # Check if TypeScript compilation was actually done
        if [ -f "dist/src/bot/index.js" ]; then
          echo "‚úÖ npm run build completed successfully and produced TypeScript output"
        else
          echo "‚ö†Ô∏è  npm run build completed but did not produce TypeScript output, attempting fallback to npx tsc..."
          npx tsc -p tsconfig.json || {
            echo "‚ùå TypeScript compilation failed with both npm run build and npx tsc"
            exit 1
          }
          echo "‚úÖ Fallback TypeScript compilation completed"
        fi
        
        # Verify the expected output file exists
        if [ -f "dist/src/bot/index.js" ]; then
          echo "‚úÖ Verified: dist/src/bot/index.js exists"
          ls -la dist/src/bot/index.js
        else
          echo "‚ùå CRITICAL: dist/src/bot/index.js was not created by compilation"
          echo "üìÇ Directory listing of dist/:"
          find dist/ -name "*.js" | head -20 || echo "No JS files found in dist/"
          echo "üìÇ Full dist structure:"
          ls -la dist/ || echo "dist/ directory does not exist"
          exit 1
        fi
        
    - name: Prepare bot execution
      run: |
        echo "üîß Bot Execution Configuration:"
        echo "   Execution Mode: ${{ inputs.execution_mode }}"
        echo "   Duration: ${{ inputs.duration_seconds }} seconds"
        echo "   Log Level: ${{ inputs.log_level }}"
        echo "   Bot Command: ${{ inputs.bot_command }}"
        echo "   Fork Preflight: ${{ inputs.fork_preflight }}"
        echo ""
        
        # Determine the command to run
        if [ "${{ inputs.execution_mode }}" = "compiled" ]; then
          BOT_CMD="npm run start -- ${{ inputs.bot_command }}"
          echo "ü§ñ Resolved Command: $BOT_CMD (compiled TypeScript)"
          echo "üìÅ Expected Target: dist/src/bot/index.js"
        else
          BOT_CMD="npm run live -- ${{ inputs.bot_command }}"
          echo "ü§ñ Resolved Command: $BOT_CMD (ts-node direct execution)"
          echo "üìÅ Expected Target: src/bot/index.ts"
        fi
        
        # Store the command for the next step
        echo "BOT_CMD=$BOT_CMD" >> $GITHUB_ENV
        
    - name: Start live bot with timeout
      id: start-live-bot-with-timeout
      run: |
        echo "üöÄ Starting live bot..."
        echo "üìÖ Start time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo "‚è∞ Duration: ${{ inputs.duration_seconds }} seconds"
        echo ""
        
        # Create output directory for logs
        mkdir -p live-bot-logs
        
        # Use the command determined in the previous step
        echo "ü§ñ Command: $BOT_CMD"
        echo "üß† Node.js heap: 6GB (via NODE_OPTIONS)"
        echo ""
        
        # Run the bot with hard timeout enforcement using GNU timeout
        # --foreground: run in foreground to receive signals properly
        # --kill-after=30: send SIGKILL after 30 seconds if SIGTERM doesn't work
        # --signal=TERM: send SIGTERM first for graceful shutdown
        timeout --foreground --kill-after=30 --signal=TERM ${{ inputs.duration_seconds }}s $BOT_CMD 2>&1 | tee live-bot-logs/bot-output.log || {
          exit_code=$?
          if [ $exit_code -eq 124 ]; then
            echo ""
            echo "‚è∞ Bot run completed - reached timeout limit of ${{ inputs.duration_seconds }} seconds"
            echo "üìÖ End time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            echo "‚úÖ Process terminated gracefully by timeout"
            exit 0
          elif [ $exit_code -eq 137 ]; then
            echo ""
            echo "‚è∞ Bot run completed - forcefully killed after timeout grace period"
            echo "üìÖ End time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            echo "‚ö†Ô∏è  Process required SIGKILL to terminate"
            exit 0
          else
            echo ""
            echo "‚ùå Bot exited with error code $exit_code"
            exit $exit_code
          fi
        }
        
        echo ""
        echo "üìä Log files created in live-bot-logs/"
        ls -la live-bot-logs/
      env:
        NODE_ENV: production
        LOG_LEVEL: ${{ inputs.log_level }}
        # Node.js memory configuration - 6GB heap for GitHub-hosted runners
        NODE_OPTIONS: "--max-old-space-size=6144"
        # Fork simulation preflight (controlled by input, defaults to false for CI safety)
        ENABLE_FORK_SIM_PREFLIGHT: ${{ inputs.fork_preflight }}
        # Secrets
        RPC_URL_HTTP: ${{ secrets.RPC_URL_HTTP }}
        RPC_URL_WS: ${{ secrets.RPC_URL_WS }}
        PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
        FLASHBOTS_SIGNING_KEY: ${{ secrets.FLASHBOTS_SIGNING_KEY }}
        FLASHBOTS_RELAY_URL: ${{ secrets.FLASHBOTS_RELAY_URL }}
        ETHERSCAN_API_KEY: ${{ secrets.ETHERSCAN_API_KEY }}
        BLOCKNATIVE_API_KEY: ${{ secrets.BLOCKNATIVE_API_KEY }}
        # Variables
        SIMULATION_MODE: ${{ vars.SIMULATION_MODE }}
        ENABLE_FLASHBOTS: ${{ vars.ENABLE_FLASHBOTS }}
        MAX_FLASHLOAN_AMOUNT_USD: ${{ vars.MAX_FLASHLOAN_AMOUNT_USD }}
        GLOBAL_MIN_PROFIT_USD: ${{ vars.GLOBAL_MIN_PROFIT_USD }}
        MAX_GAS_GWEI: ${{ vars.MAX_GAS_GWEI }}
        BUNDLE_GAS_LIMIT: ${{ vars.BUNDLE_GAS_LIMIT }}
        POOL_MAX_FAILURES: ${{ vars.POOL_MAX_FAILURES }}
        POOL_COOLDOWN_MS: ${{ vars.POOL_COOLDOWN_MS }}
        REQUIRE_RAW_TX_HEX: ${{ vars.REQUIRE_RAW_TX_HEX }}
        ONE_BUNDLE_PER_BLOCK: ${{ vars.ONE_BUNDLE_PER_BLOCK }}
        I_UNDERSTAND_LIVE_RISK: ${{ vars.I_UNDERSTAND_LIVE_RISK }}
        CONFIRM_MAINNET: ${{ vars.CONFIRM_MAINNET }}
        
    - name: Upload bot logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: live-bot-logs-${{ github.run_number }}
        path: |
          live-bot-logs/
        retention-days: 7
        
    - name: Run summary
      if: always()
      run: |
        echo "## ü§ñ Live Bot Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Test Type:** Limited-time live bot execution" >> $GITHUB_STEP_SUMMARY
        echo "**Duration:** ${{ inputs.duration_seconds }} seconds" >> $GITHUB_STEP_SUMMARY
        echo "**Mode:** ${{ inputs.execution_mode }}" >> $GITHUB_STEP_SUMMARY
        echo "**Bot Command:** ${{ inputs.bot_command }}" >> $GITHUB_STEP_SUMMARY
        echo "**Fork Preflight:** ${{ inputs.fork_preflight }}" >> $GITHUB_STEP_SUMMARY
        echo "**Node.js Heap:** 6GB (enhanced for memory-intensive operations)" >> $GITHUB_STEP_SUMMARY
        echo "**Timestamp:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check if the bot execution step succeeded (exit codes 0, 124, 137 are all considered successful completions)
        if [ "${{ steps.start-live-bot-with-timeout.outcome }}" = "success" ]; then
          echo "**Result:** ‚úÖ COMPLETED" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Run Summary:" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Bot started successfully" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Ran for configured duration" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Process terminated within timeout limits" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Logs captured and uploaded" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the log artifacts to analyze bot behavior" >> $GITHUB_STEP_SUMMARY
          echo "2. Check for any opportunities detected or trades executed" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor gas usage and profit calculations" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Result:** ‚ùå FAILED" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Troubleshooting:" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the log artifacts for error details" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify all secrets and variables are correctly configured" >> $GITHUB_STEP_SUMMARY
          echo "3. Ensure sufficient ETH balance for gas costs" >> $GITHUB_STEP_SUMMARY
          echo "4. Check if the issue was a Node.js out-of-memory error (now mitigated with 6GB heap)" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Log Artifact:** \`live-bot-logs-${{ github.run_number }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ‚ö†Ô∏è Safety Notice:" >> $GITHUB_STEP_SUMMARY
        echo "This workflow runs the bot with real funds and smart contracts." >> $GITHUB_STEP_SUMMARY
        echo "Always monitor executions and ensure adequate safety limits are configured." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîß Enhanced Features:" >> $GITHUB_STEP_SUMMARY
        echo "- **Hard Timeout Enforcement:** Uses GNU timeout with SIGTERM/SIGKILL for reliable process termination" >> $GITHUB_STEP_SUMMARY
        echo "- **Memory Management:** 6GB Node.js heap to prevent out-of-memory crashes during simulation" >> $GITHUB_STEP_SUMMARY
        echo "- **Reliable Logging:** Logs are always uploaded regardless of execution outcome" >> $GITHUB_STEP_SUMMARY